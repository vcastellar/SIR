#' Plot a simulated epidemic
#'
#' @name plot.sim_epi
#'
#' @description
#' Plot method for objects of class \code{"sim_epi"} as returned by
#' \code{\link{simulate_epi}}. The function can display either the compartmental
#' state trajectories (S, E, I, R) or the observed incidence time series, depending
#' on the value of the \code{what} argument. When plotting states, the function
#' can optionally include cumulative infections and adjust the display scale.
#'
#' @details
#' When \code{what = "states"}, the function plots the time evolution of the
#' susceptible (S), exposed (E), infectious (I), and recovered (R) compartments
#' on the same figure when available. When \code{what = "incidence"}, the function plots the observed
#' incidence counts generated by the observation model.
#'
#' This method is automatically dispatched when calling \code{plot()} on an
#' object of class \code{"sim_epi"}.
#'
#' @param x Object of class \code{"sim_epi"} as returned by
#'   \code{\link{simulate_epi}}.
#' @param what Character. Type of plot to produce. Either \code{"states"} for the
#'   compartmental trajectories (S, E, I, R) or \code{"incidence"} for the observed
#'   incidence time series.
#' @param include_C Logical. If \code{TRUE} and the state \code{C} is present,
#'   include cumulative infections in the state plot.
#' @param scale Character. Scale for state plots. One of \code{"auto"},
#'   \code{"full"}, \code{"small"}, or \code{"log"}.
#' @param ... Additional graphical parameters passed to base plotting functions
#'   such as \code{\link{plot}} and \code{\link{lines}}.
#'
#' @return Invisibly returns the input object \code{x}.
#'
#' @seealso
#' \code{\link{simulate_epi}}, \code{\link{summary.epi_sim}}
#'
#' @examples
#' sim <- simulate_epi(n_days = 200, model = SIR_MODEL, seed = 1)
#'
#' # Plot S, I, R trajectories
#' plot(sim)
#'
#' # Plot observed incidence
#' plot(sim, what = "incidence")
#'
#' @export
plot.sim_epi <- function(x,
                         what = c("states", "incidence"),
                         include_C = FALSE,
                         scale = c("auto", "full", "small", "log"),
                         ...) {
  what  <- match.arg(what)
  scale <- match.arg(scale)

  if (!is.list(x) || is.null(x$states)) {
    stop("Invalid 'sim_epi' object: missing $states.")
  }

  if (what == "states") {
    st <- x$states

    # estados disponibles típicos
    base_states <- c("S", "E", "I", "R")
    states <- intersect(base_states, names(st))

    if (include_C && "C" %in% names(st)) states <- c(states, "C")
    if (length(states) == 0) stop("No plottable states found in x$states.")

    # datos a graficar
    y <- st[, states, drop = FALSE]

    # elección de escala automática:
    # si S domina mucho, hacemos zoom a (E,I,R) o (I,R) si no hay E
    if (scale == "auto") {
      if ("S" %in% states) {
        others <- setdiff(states, c("S", "C"))
        if (length(others) > 0) {
          ratio <- max(st$S, na.rm = TRUE) / max(st[, others, drop = FALSE], na.rm = TRUE)
          scale <- if (is.finite(ratio) && ratio > 100) "small" else "full"
        } else {
          scale <- "full"
        }
      } else {
        scale <- "full"
      }
    }

    # define qué se muestra en cada escala
    if (scale == "small") {
      states_to_plot <- setdiff(states, c("S", "C"))
      if (length(states_to_plot) == 0) states_to_plot <- setdiff(states, "S")
      yplot <- st[, states_to_plot, drop = FALSE]
      ylim <- range(yplot, finite = TRUE)
      ylab <- "Individuals (zoomed)"
      log_arg <- ""
    } else if (scale == "log") {
      states_to_plot <- setdiff(states, "C")   # C en log suele estorbar
      yplot <- st[, states_to_plot, drop = FALSE]
      yplot[yplot <= 0] <- NA_real_
      ylim <- range(yplot, finite = TRUE)
      ylab <- "Individuals (log scale)"
      log_arg <- "y"
    } else { # full
      states_to_plot <- states
      yplot <- st[, states_to_plot, drop = FALSE]
      ylim <- c(0, max(yplot, na.rm = TRUE))
      ylab <- "Number of individuals"
      log_arg <- ""
    }

    # estilos por estado (fijos, no dependen del orden)
    col_map <- c(S = "black", E = "darkgreen", I = "red", R = "blue", C = "grey40")
    lty_map <- c(S = 1,       E = 4,          I = 2,     R = 3,      C = 1)
    lwd_map <- c(S = 2,       E = 2,          I = 2,     R = 2,      C = 1)

    cols <- col_map[states_to_plot]
    ltys <- lty_map[states_to_plot]
    lwds <- lwd_map[states_to_plot]

    # plot
    first <- states_to_plot[1]
    plot(st$time, yplot[[first]],
         type = "l",
         col = cols[[1]],
         lty = ltys[[1]],
         lwd = lwds[[1]],
         xlab = "Time (days)",
         ylab = ylab,
         main = paste("Simulation:", x$model),
         ylim = ylim,
         log = log_arg,
         ...)

    if (length(states_to_plot) > 1) {
      for (k in 2:length(states_to_plot)) {
        nm <- states_to_plot[k]
        lines(st$time, yplot[[nm]],
              col = cols[[k]],
              lty = ltys[[k]],
              lwd = lwds[[k]])
      }
    }

    # leyenda
    label_map <- c(
      S = "(S) Susceptible",
      E = "(E) Exposed",
      I = "(I) Infectious",
      R = "(R) Recovered",
      C = "(C) Cumulative"
    )

    legend("topright",
           legend = unname(label_map[states_to_plot]),
           col    = unname(cols),
           lty    = unname(ltys),
           lwd    = unname(lwds),
           bty    = "n")

  } else {
    inc <- x$incidence_obs
    if (is.null(inc) || is.null(inc$time) || is.null(inc$inc)) {
      stop("Invalid 'sim_epi' object: missing $incidence_obs with columns time/inc.")
    }

    plot(inc$time, inc$inc,
         type = "h",
         xlab = "Time (days)",
         ylab = "Observed incidence",
         main = paste("Observed incidence:", x$model),
         ...)
  }

  invisible(x)
}


#' Summarize a simulated epidemic
#'
#' @name summary.sim_epi
#'
#' @description
#' Summary method for objects of class \code{"sim_epi"} as returned by
#' \code{\link{simulate_epi}}. The function computes and returns a small set of
#' epidemiologically meaningful summary quantities derived from the simulation.
#'
#' @details
#' The summary includes:
#' \describe{
#'   \item{model}{The epidemic model simulated (e.g. \code{"sir"} or \code{"sirs"}).}
#'   \item{R0}{The basic reproduction number, computed as
#'     \eqn{R_0 = \beta / \gamma}.}
#'   \item{peak_I}{The maximum number of infectious individuals observed during
#'     the simulation.}
#'   \item{total_infections}{The total number of infection events, computed as
#'     the maximum value of the cumulative infection variable \code{C(t)}.}
#' }
#'
#' This method is automatically dispatched when calling \code{summary()} on an
#' object of class \code{"sim_epi"}.
#'
#' @param object Object of class \code{"sim_epi"} as returned by
#'   \code{\link{simulate_epi}}.
#' @param ... Currently unused; included for compatibility with generic
#'   \code{\link{summary}}.
#'
#' @return
#' A named list with summary statistics describing the simulated epidemic.
#'
#' @seealso
#' \code{\link{simulate_epi}}, \code{\link{plot.sim_epi}}
#'
#' @examples
#' sim <- simulate_epi(n_days = 300, model = SIRS_MODEL, omega = 1/180, seed = 1)
#'
#' summary(sim)
#'
#' @export
summary.sim_epi <- function(object, ...) {

  st  <- object$states
  inc <- object$incidence

  res <- list(
    model = object$model
  )

  if ("I" %in% names(st)) {
    res$peak_I <- max(st$I, na.rm = TRUE)
    res$time_peak_I <- st$time[which.max(st$I)]
  }

  if (!is.null(inc) && "inc" %in% names(inc)) {
    res$total_infections <- sum(inc$inc, na.rm = TRUE)
  }

  res
}



#' Print a simulated epidemic
#'
#' @name print.sim_epi
#'
#' @description
#' Print method for objects of class \code{"sim_epi"} as returned by
#' \code{\link{simulate_epi}}. The function provides a concise, human-readable
#' summary of the simulated epidemic, including the model type, time horizon,
#' key parameters, and basic outcome metrics.
#'
#' @details
#' This method is automatically called when an object of class \code{"sim_epi"}
#' is printed. It is intended to give a quick overview without displaying the
#' full internal structure of the object.
#'
#' @param x Object of class \code{"sim_epi"} as returned by
#'   \code{\link{simulate_epi}}.
#' @param ... Currently unused; included for compatibility with generic dispatch.
#'
#' @return
#' Invisibly returns the input object \code{x}.
#'
#' @seealso
#' \code{\link{simulate_epi}}, \code{\link{summary.sim_epi}}, \code{\link{plot.sim_epi}}
#'
#' @examples
#' sim <- simulate_epi(n_days = 200, model = SIRS_MODEL,
#'                     beta = 0.30, gamma = 0.10, omega = 1/180)
#'
#' sim
#'
#' @export
print.sim_epi <- function(x, ...) {

  stopifnot(inherits(x, "sim_epi"))

  st  <- x$states
  inc <- x$incidence

  cat("Epidemic simulation\n")
  cat("-------------------\n")

  cat("Model:        ", x$model, "\n", sep = "")
  cat("Time horizon: ", max(st$time), " days\n", sep = "")

  cat("\nOutcomes\n")

  if ("I" %in% names(st)) {
    peak_I  <- max(st$I, na.rm = TRUE)
    time_pk <- st$time[which.max(st$I)]
    cat("  Peak infectious (I): ", round(peak_I), "\n", sep = "")
    cat("  Time of peak:        ", time_pk, " days\n", sep = "")
  }

  if (!is.null(inc) && "inc" %in% names(inc)) {
    total <- sum(inc$inc, na.rm = TRUE)
    cat("  Total infections:    ", round(total), "\n", sep = "")
  }

  invisible(x)
}
